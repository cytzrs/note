缓冲(Buffer)
缓冲区是一块特定内存区域。开辟缓冲区的目的是通过缓解应用程序上上下层之间的性能差异，提高系统的性能。缓冲可以协调上层组件和下层组件之间的性能差。当上层组件性能优于下层组件时可以有效减少上层组件对下层组件的等待时间。基于这样的结构，上层应用组件不需要等待下层组件真是的接受全部数据，即可返回操作，加快了上层组件的处理速度，从而提升系统整体性能。
一般来说，缓冲区不宜过小，过小的缓冲区无法起到真正的缓冲作用，缓冲区也不宜过大，过大的缓冲区会浪费系统内存，增加GC负担。
除了性能上的优化，缓冲区还可以作为上层组件和下层组件的一种通信工具。

缓存(Cache)
缓存也是一种为提升系统性能而开辟的内存空间。缓存的主要作用是暂存数据处理结果，并提供下次访问使用。字很多场合，数据的处理或者数据获取可能会非常费时，对当这个数据的请求量很大时，频繁的数据处理会耗尽CPU资源。缓存的作用就是将这些来之不易的数据处理结果暂存起来，当有其他线程或者客户端需要查询相同的数据资源时，可以省略对这些数据的处理流程，而直接从缓存中获取处理结果，并立即返回给请求组件，以此提高系统的响应时间。
缓存可以保存一些来之不易的数据或者计算结果。当需要再次使用这些数据时，可以从缓冲中低成本地获取，而不需要再占用宝贵的系统资源。
常用的基于Java的缓存框架，比如EHCache，OSCache和JBossCache等。EHCache缓存出自Hibernate，是Hibernate框架默认的数据缓存解决方案；OSCache缓存是由OpenSymphony设计的，它可以用于缓存任何对象，甚至是缓存部分JSP分页或者HTTP请求；JBossCache是由JBoss开发，可用于JBoss集群间数据共享的缓存方案。
在为方法加入缓存时，可以使用最原始的硬编码方式，根据传入的参数构造key，然后去缓存中查找结果，如果找到则立即返回；如果找不到，则再根据相关的业务逻辑处理，得到最终结果，并将结果保存到缓存中，并返回这个结果。这种方式实现的好处是代码比较直白，缺点是缓存组件和业务层代码紧密耦合，依赖性强。我们可以通过动态代理的缓存方案的最大好处是，在业务层，无需关注对缓存的操作，缓存操作代码被完全独立并隔离，并且对一个新的函数方法并加入缓存不会影响原有的方法实现，是一种非常灵活的软件结果。

对象服用-“池”
对象池化，是目前非常常用的一种系统优化技术。它的核心思想是，如果一个类被频繁请求试用，那么不必每次都生成一个实例，可以将这个类的一些实例保存在一个”池”中，待需要使用的时候直接从池中获取。这个“池”就成为对象池。在实现细节上，他可能是一个数组，一个链表或者任何集合类。对象池的使用非常广泛，其中最为大家所熟悉的，就是线程池和数据库连接池。线程池中，保存着可以被重用的线程对象，当有任务被提交到线程池时，系统并不需要新建线程，而是从池中获得一个可用的线程，执行这个任务。在任务结束后，也不关闭线程，而将它返回到池中，以便一次继续使用。由于线程的创建和销毁是较为费力费时的工作，因此，在线程调度频繁的系统中，线程池可以很好地改善性能。
数据库连接池也是一种特殊的对象池，它用于维护数据库连接的集合。当系统需要在访问数据库时，不需要重新建立数据库连接，而可以直接从池中获取；在数据库操作完成后，也不必关闭数据库连接，而是将连接返回到连接池中。由于数据库连接的创建和销毁是重量级的操作，因此，避免频繁的进行这两个操作，对改善系统的性能也有积极意义。
在程序中使用数据库连接池和线程池，可以有效地改善系统在高并发下的性能，这是两个非常重要的性能组件。任何对性能敏感的系统，都需要考虑合理配置这连个组件。
除了线程池和数据库连接池，对于普通的Java对象，在必要时也可以进行池化管理。对于经常使用，并且创建很费时的大型对象来说，在使用对象池维护，不仅可以节省对象实例的成本，还可以减轻GC频繁回首这些对象产生的系统压力。但对于生成对象开销很小的兑现进行池化，反而可能得不偿失，维护对象池的成本可能会大于对象池带来的好处。
在JDK中，new操作的频率是相当高的，不需要担心频繁的new操作对系统有性能影响。但是new操作时所需要调用的类构造函数可能时非常费时的，对于这些对象，可以考虑池化。
Apache Jakarta Commons Pool，对象池组件
Jakarta Commons Pool定义的对象池接口如下：
public interface ObjectPool<T> {
  T borrowObject();
  void returnObject(T borrowed);
}
其中borrowObjec()方法从对象池中获得一个对象。returnObject()方法在使用完成后，将对象返回给对象池。
另一个重要接口是PoolableObjectFactory，它会告诉对象池如何创建一个对象，如何销毁另一个对象。
public interface PoolableObjectFactory<T> {
  T makeObject();  创建一个新的对象实例
  void activeObject(T obj);   在对象从对象池取出前，会激活这对象
  void passivateObject(T obj);    在对象返回对象池时被调用
  boolean validateObject(T obj);    判断对象是否可用
  void destoryObject(T obj);    对象从对象池中被销毁时，会执行这个方法
}
PoolableObjectFactory接口方法都将被对象池回调，以知道对象池在对象的生命周期中如何管理这些对象。
Jakarta内置了三种对象池，分别时:
1,StackObjectPool,使用java.util.Stack来保存对象，可以为StackObjectPool指定一个初始化大小，并且当空间不够时，StackObjectPool可以自动增长。当无法从该对象池得到可用的对象时，它会自动创建新的对象。
2,GenericObjectPool，是一个通用的对象池，可以设定对象池的容量，也可以设定在无可用对象的情况下，对象池的表现行为(等待或者创建新的对象实例)，还可以设置是否进行对象的有效性检查。GenericObjectPool有一个复杂的构造函数来定义它的这些行为。
3,SoftReferenceObjectPool，使用ArrayList保存对象，但是SoftReferenceObjectPool并不直接保存对象的强引用，而是保存对象的软引用，它使用如下方法向池中加入新对象.pool.add(new SoftReference<T>(obj, refQueue));SoftReferenceObjectPool对对象的数量没有限制，当对象池没有可用对象时，borrow()方法会创建新的对象，当内存紧张时，JVM可以自动收回具有软引用的对象。

并行替代串行:

负载均衡：
对于大型应用来说，系统负载可能非常重。以网站为例，如果并发数很多，则单台计算机就无法承受，此时，为了保证应用程序的服务质量，需要使用多台计算机协同工作，将系统负载尽可能均衡分配到各个计算机节点。一个典型的实现就是Tomcat集群。配Tomcat集群实现负载均衡，可以通过Apache服务器实现。使用Apache服务器作为负载分配器，将请求转向到各个Tomcat服务器，从而实现负载均衡。
在使用Tomcat集群时，有两种基本的Session共享模式。
1，黏性Session模式，所有的Session信息被平均分配到各个Tomcat节点上，以实现负载均衡，但是一旦有一个节点宕机，它所维护的Session信息将丢失，不具备高可用性，且同一用户只能与一台Tomcat交互，因为其他Tomcat节点上不保存这个用户信息。
2，复制Session模式，将所有的Session在所有Tomcat节点保持一致。当一个节点上的Session信息被修改，这个Session会被广播到其他Tomcat节点上，以保持Session同步，这样，当用户下一次请求被分配到其他Tomcat节点上时，将拥有足够信息处理用户请求。这样的做的坏处时，很容易引起网络繁忙，影响系统效率。
Terracotta，跨JVM虚拟机，专门用于分布式缓存框架。用Terracotta也可以实现Tomcat的Session共享。同事Terracotta也是一个成熟的高可用性系统解决方案。Terracotta进行内存共享时，并不会进行全复制，而仅仅传输变化的部分，网络负载也相对较低。

时间换空间：
时间换空间通常用于嵌入式设备，或者内存，硬盘空间不足的情况下。通过使用牺牲CPU的方式，获取原本需要更多内存或者硬盘空间才能完成的工作。
典型的如：
a = a + b;b = a -b;a = a -b;这是一种时间换空间的做法，实现了a,b两个变量的值交换
空间换时间：
空间换时间则是尝试使用更多的内存或者磁盘空间换取CPU资源或者网络资源，通过增加系统的内存消耗，来加快程序的运行速度。这种典型的应用就是缓存。缓存时一块额外的系统内存区，如果没有缓存，程序依然可以正常工作。但是，在已在一般情况下，缓存中总是保存那些来之不易的数据，重新取得这些数据会花费大量的资源和时间。而通过缓存这块额外的内存，避免了频繁的资源消耗，加快了程序的运行速度。
public static void spaceToTime(int[] array) {
		int i = 0;
		int max = array[0];
		int l = array.length;
		for (i = 1; i < l; i++)
			if (array[i] > max)			// 找出最大值
				max = array[i];
		int[] temp = new int[max + 1]; 	
		for (i = 0; i < l; i++)
			temp[array[i]] = array[i];
		int j = 0;
		int max1 = max + 1;
		for (i = 0; i < max1; i++) { 	
			if (temp[i] > 0) {
				array[j++] = temp[i];
			}
		}
	}
